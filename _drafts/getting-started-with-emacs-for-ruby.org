---
title: "Getting Started with Emacs for Ruby"
layout: post
---

Lately I've been slowly bringing a few of my students at Turing into the Emacs fold. Along the way I've been thinking about what a sufficient but minimal beginner's Emacs setup for working with Ruby code would look like. In this post I'll try to document some of the tools and configuration we've found useful. I'm also hoping to re-use much of this material for a "Beginner's Intro to Emacs" session we're offering at Turing in a few weeks, so this material is targeted at emacs newcomers.

** Emacs Configuration 101

The Emacs configuration journey starts with a special directory on your machine located at =~/.emacs.d=. When Emacs starts up, it will by default look for a file called =init.el= in this directory and use that to load any user-specific configuration you want to provide. (This is similar to how your shell loads any user configuration files at =~/.profile= or =~/.bashrc=, etc)

To follow along, go ahead and create this directory and file:

: mkdir ~/.emacs.d
: touch ~/.emacs.d/init.el

If your machine already has an emacs install in this directory and you want to start from scratch, it's safe to stash the existing directory by moving it:

: mv ~/.emacs.d ~/.emacs.d.old

Your original config will be safely waiting for you should you decide to return to it.

*** Baby's First Emacs Lisp

A suspicious reader may have noticed the file extension on the init file we just created: =.el=. This stands for Emacs Lisp, the language in which Emacs is written and scripted. It turns out Emacs is basically a big old Lisp interpreter with a bunch of neat features for manipulating text buffers thrown in for kicks. So are we about to be writing... /Lisp/? You bet your Auntie's parentheses we are!

When Emacs boots, it will process our =init.el= as Emacs Lisp, so within this file we'll be writing Elisp expressions to customize how the editor behaves.

** Emacs: Out of the 1990's

Despite its endearing homeliness, a fresh Emacs installation makes a somewhat dated first impression:

[[/public/images/emacs_splash_screen.png]]

The default Emacs configuration includes some clunky things like menu bars and a loud "splash" screen. [[https://github.com/technomancy/better-defaults][BetterDefaults]] is a popular Emacs package for this purpose -- it provides more reasonable defaults for some of Emacs' more idiosyncratic built-in features.

It also gives us a good opportunity to talk about...

*** Emacs Packages

The standard unit of distributing some Emacs code is a "package." There are several free online package repositories out there, the most popular being [[https://elpa.gnu.org/][GNU ELPA]], [[https://www.emacswiki.org/emacs/ELPA][ELPA]], [[https://marmalade-repo.org/][Marmalade]], and [[https://melpa.org/][Melpa]].

Unfortunately, Emacs doesn't come with a built-in solution for defining what packages we want to use in a "manifest" format (like we might encounter with a Gemfile or package.json in a Ruby or Node project).

Fortunately it's pretty easy to add this functionality, so go ahead and add this Elisp to your =init.el=:

#+BEGIN_SRC emacs-lisp
; list the repositories containing them
(setq package-archives '(("elpa" . "http://tromey.com/elpa/")
                         ("gnu" . "http://elpa.gnu.org/packages/")
                         ("melpa" . "https://melpa.org/packages/")
                         ("marmalade" . "http://marmalade-repo.org/packages/")))

; activate all the packages (in particular autoloads)
(package-initialize)

; fetch the list of packages available
(unless package-archive-contents
  (package-refresh-contents))

; list the packages you want
(setq package-list '(better-defaults))

; install the missing packages
(dolist (package package-list)
  (unless (package-installed-p package)
    (package-install package)))

(require 'better-defaults)
#+END_SRC

This first Elisp snippet lets us define a list of package archives, define a list of packages we want to install, and then, if any of them are missing, install them automatically. From now on, we can simply add packages to our =package-list= and they should be automatically installed when we start emacs.

The =require= expression on the last line loads the better-defaults package that we just installed, so you should see it taking effect.

Save this file and restart emacs if it's already running (remember: =C-x C-c= to quit), and you should see emacs pause briefly as it installs the Better Defaults package. Then you should see a slightly cleaner interface now that the toolbars are removed.

** A Bit More UI:

Next let's get rid of the default Emacs splash screen and have it put us into an empty buffer instead. The =initial-major-mode= setting can take any of Emacs' major modes -- a lot of people use Org or Markdown mode for their scratch buffer, but since we're targeting a Ruby setup here, we'll use that.

#+BEGIN_SRC emacs-lisp
(setq inhibit-splash-screen t
      initial-scratch-message nil
      initial-major-mode 'ruby-mode)
#+END_SRC

Additionally, it would be nice if it didn't look so glaringly white. Let's update our package list to pull in the ever-gentle-on-the-eyes [[https://github.com/bbatsov/solarized-emacs][Solarized Theme]] and load it in our init file:

#+BEGIN_SRC emacs-lisp
(setq package-list '(better-defaults solarized-theme))

;....

(load-theme 'solarized-dark t)
#+END_SRC

Finally, we add a few more bits of snazz like showing line numbers and setting a default font ([[https://github.com/adobe-fonts/source-code-pro][SourceCodePro]] is a free, open source monospaced font for editing code from Adobe.)

#+BEGIN_SRC emacs-lisp
;; Show line numbers
(global-linum-mode)

;; Typography
(set-face-attribute 'default nil
                    :family "Source Code Pro"
                    :height 150
                    :weight 'normal
                    :width 'normal)
#+END_SRC

** OS X Conveniences

I generally recommend people start using Emacs using its GUI mode. Personally I still use this mode most often even a few years into using Emacs, but when starting out it's especially helpful to have some of the familiar OS X keybindings for Copying, Pasting, Cmd-Tabbing, etc. On a Mac you'll have this available if you installed using homebrew with the =--with-cocoa= flag (=brew install emacs --with-cocoa=).

It's also convenient to be able to open your editor from the command line and pass it a file or directory to start with. To make this easy, you can add this function to your shell profile (=~/.bashrc=, =~/.bash_profile=, etc):

#+BEGIN_SRC sh
em () { open -a /usr/local/Cellar/emacs/24.5/Emacs.app/Contents/MacOS/Emacs $* }
#+END_SRC

Then from the command line you'll be able to do things like =em pizza.el= to open that file in an Emacs Cocoa app window.

** Editor Basics: Find-In-Project and Ctrl-P

Finally let's try to tick off a couple more features from the "What would I miss if I started using Emacs from Atom/SublimeText/TextMate?" list. The 2 of these I find most essential are:
  * "Ctrl-P"-style command to fuzzily find a file in the current project
  * Find-in-Project text search for finding an arbitrary string in the current project

We can get these features pretty easily using 3 popular packages: [[https://github.com/emacs-helm/helm][Helm]], [[https://github.com/bbatsov/helm-projectile][Helm Projectile]] and [[https://github.com/syohex/emacs-helm-ag][Helm ag]]. Helm is actually something of a "parent" package for these other 2 -- Helm provides a generalized framework for doing the kind of slick "fuzzily-search some text in a list of stuff" interface that we all know and love. Then other packages like Helm Projectile and Helm ag can take advantage of this interaction to build neat tools like "find a file in my project" or "find some text in my project."

Add these to your =package-list= and give them some basic keybinds as follows:


#+BEGIN_SRC emacs-lisp
(setq package-list '(better-defaults
                     solarized-theme
                     helm
                     helm-projectile
                     helm-ag))

(global-set-key (kbd "M-x") #'helm-M-x)
(global-set-key (kbd "s-f") #'helm-projectile-ag)
(global-set-key (kbd "s-t") #'helm-projectile-find-file-dwim)
#+END_SRC

The =s= in the keybinds here stands for the "Super" which in the OS X Cocoa app should be your =CMD= Key. So this gives us the familiar =Cmd-f= for "search for text in this project" and =Cmd-t= for "find files in my project." Finally we also over-write the default =M-x= keybinding to use helm's interface for searching for Emacs commands to run. This makes more complex Emacs commands much more discoverable.

** Ruby Basics: Highlighting and Auto-matching

Now that we've tamed Emacs into a slightly more well-behaved general editing environment, we can finally dive into our Ruby setup!

Let's start with a bit of basic auto-matching for paired characters (parens, quotes, def/class/if-end, etc). Add =ruby-electric= to your package list and tell emacs to require it automatically whenever we enter ruby mode like so:

#+BEGIN_SRC emacs-lisp
(setq package-list '(better-defaults
                     solarized-theme
                     helm-projectile
                     helm-ag
                     ruby-electric))

;...

;; Autoclose paired syntax elements like parens, quotes, etc
(add-hook 'ruby-mode-hook ruby-electric-mode)
#+END_SRC

Sometimes Ruby code appears in other kinds of files that don't end with the standard =.rb= extension. We can tell emacs to treat these as ruby files using this snippet:


#+BEGIN_SRC emacs-lisp
  (add-to-list 'auto-mode-alist
               '("\\.\\(?:cap\\|gemspec\\|irbrc\\|gemrc\\|rake\\|rb\\|ru\\|thor\\)\\'" . ruby-mode))
  (add-to-list 'auto-mode-alist
               '("\\(?:Brewfile\\|Capfile\\|Gemfile\\(?:\\.[a-zA-Z0-9._-]+\\)?\\|[rR]akefile\\)\\'" . ruby-mode))

#+END_SRC

** Ruby Version Manager

Most Ruby developers these days are using some kind of Version Manager to simplify the process of installing and jumping around between various ruby versions. This is a great feature to have, but it unfortunately adds another layer of indirection between emacs and the Ruby installation living on our machine. And to further complicate things, the community hasn't really standardized on any of the particular options, which means you're likely using one of Rbenv, RVM, or Chruby. Depending on which of these you're using, you'll want to pull in the appropriate config below:

*** RVM (Using [[https://github.com/senny/rvm.el][rvm.el]])

Add the =rvm= package and invoke it using =(rvm-use-default)=

#+BEGIN_SRC emacs-lisp
(setq package-list '(better-defaults
                     solarized-theme
                     helm-projectile
                     helm-ag
                     ruby-electric
                     rvm))
;...

(rvm-use-default)
#+END_SRC

*** RBENV (using [[https://github.com/senny/rbenv.el][rbenv.el]] )

#+BEGIN_SRC emacs-lisp
(setq package-list '(better-defaults
                     solarized-theme
                     helm-projectile
                     helm-ag
                     ruby-electric
                     rbenv))
;...

(global-rbenv-mode)
(rbenv-use-global)

;; Optional -- if your RBENV installation is located somewhere besides
;; ~/.rbenv, you will need to configure this:
;;(setq rbenv-installation-dir "/usr/local/rbenv")

#+END_SRC

*** Chruby (using [[https://github.com/plexus/chruby.el][chruby.el]])

#+BEGIN_SRC emacs-lisp
(setq package-list '(better-defaults
                     solarized-theme
                     helm-projectile
                     helm-ag
                     ruby-electric
                     chruby))
;...

(chruby "2.2.2") ;;  or whichever version you want to use
#+END_SRC
** Ruby Interactions: The Once and Future Workflow

Now that we've diligently gotten our groundwork out of the way, we can at last get into the good stuff. In this section we'll look at several tools for working interactively with Ruby code from within Emacs. Features like this are ultimately one of the biggest reasons for using Emacs in the first place. As we set up these features we'll take a few key code interaction patterns and focus on making them as smooth as possible. Specifically, when I'm working with Ruby code I want to be able to:
  * Arbitrarily evaluate Ruby code from the current buffer
  * Run tests from within Emacs
  * Open an interactive ruby session (i.e. REPL -- IRB or Pry) within Emacs

Let's check out some neat Emacs packages that make interactions like these possible.

*** Ruby Buffer Interaction -- Seeing truly is believing

First, install the Gem:

#+BEGIN_EXAMPLE
  gem install seeing_is_believing --version 3.0.0.beta.7
#+END_SRC

Then, add and configure the corresponding Emacs package:

#+BEGIN_SRC emacs-lisp
(setq package-list '(better-defaults
                     solarized-theme
                     helm-projectile
                     helm-ag
                     ruby-electric
                     seeing-is-believing
                     chruby))

;; ...

(setq seeing-is-believing-prefix "C-.")
(add-hook 'ruby-mode-hook 'seeing-is-believing)
(require 'seeing-is-believing)
#+END_SRC

Restart Emacs and open up a sample Ruby file. Try experimenting with the following keybindings to see what Seeing Is Believing gives us:
  * =C-. s= - Run Seeing is Believing for the entire file
  * =C-. c= - Clear the Seeing is Believing output
  * =C-. t= - Tag a line to be "targeted" for evaluation by SiB
  * =C-. x= - Run only the "tagged" lines (those with trailing "# => " markers)

Hopefully you're seeing some output show up at the end of your Ruby source lines. Seeing is Believing is a Gem that runs a chunk of Ruby code and prints out (in an existing text buffer) the result of evaluating each line. For our purposes, this gives us a very powerful way to quickly interact with a chunk of code -- directly from our Emacs buffer!

To learn more, check out the docs for the [[https://github.com/JoshCheek/seeing_is_believing][Seeing Is Believing Gem]] and [[https://github.com/jcinnamond/seeing-is-believing][seeing-is-believing.el]].

*** inf-ruby -- IRB from Emacs

Next stop is a neat package called [[https://github.com/nonsequitur/inf-ruby][inf-ruby]]. In the tradition of other Emacs Inferior Language Modes, it gives us an embedded IRB process running inside of Emacs, as well as some standard keybindings to interact with the REPL by sending code snippets to it from a buffer.

First, install and configure inf-ruby:

#+BEGIN_SRC emacs-lisp
(setq package-list '(better-defaults
                     solarized-theme
                     helm-projectile
                     helm-ag
                     ruby-electric
                     seeing-is-believing
                     chruby
                     inf-ruby))

;; ...

(autoload 'inf-ruby-minor-mode "inf-ruby" "Run an inferior Ruby process" t)
(add-hook 'ruby-mode-hook 'inf-ruby-minor-mode)
#+END_SRC

Restart Emacs then open up a Ruby file somewhere. Try out the following:
  * Use =C-c C-s= to launch the inf-ruby process.
  * Use =C-x o= to switch to the inf-ruby pane and try running some random ruby snippets as you normally would from IRB or pry.
  * Go back to your Ruby buffer, select a chunk of code, and use =C-c C-r= to *push* that Ruby code into the IRB session. For example -- try defining a class in your Ruby buffer, select the whole buffer, run =C-c C-r=, then swap over to the inf-ruby buffer and instantiate an instance of your class. Pretty cool!
  * Alternatively, use =C-c M-r= to run a selected chunk of code and automatically go to the ruby buffer
  * Finally, use =helm-M-x= (which we bound earlier to the default =M-x= keybinding) to search for "ruby send" and see what other default bindings inf-ruby gives us.
  * If you do a lot of work in Rails or Sinatra, also check out the commands =inf-ruby-console-rails= and =inf-ruby-console-racksh= -- it can also be used to start a console session in the environment of your current project.
