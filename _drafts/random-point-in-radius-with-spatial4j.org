---
title: "Random Point in Radius with Spatial4J"
layout: post
---

Recently I needed to generate random points within a given radius around a point on a map.

I found it less obvious than I expected, so I decided to document the process here in case it helps anyone.

I'm using [[https://github.com/locationtech/spatial4j][Spatial4J]], a Java geospatial library which provides utilities for doing spatial operations in a geodesic context. In particular this contrasts with the also-popular [[https://github.com/locationtech/jts][Java Topology Suite]], which provides vector-oriented geometric utilities in a Cartesian context. For mapping-oriented work where you care about normal distance units like meters, Spatial4J is often what you need.

For a real project, you'll obviously want to put this into a pom/sbt/lein/whatever config file, but for quick experimentation, you can download it from [[https://mvnrepository.com/artifact/org.locationtech.spatial4j/spatial4j/0.7][maven]]:


#+BEGIN_SRC sh
wget https://repo1.maven.org/maven2/org/locationtech/spatial4j/spatial4j/0.7/spatial4j-0.7.jar
#+END_SRC

Then in a scala repl, require it:


#+BEGIN_SRC txt
âž¸ scala
Welcome to Scala 2.12.2 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_121).
Type in expressions for evaluation. Or try :help.

scala> :require spatial4j-0.7.jar
Added '/private/tmp/spatial4j-0.7.jar' to classpath.
#+END_SRC


** Outline
Here are the rough steps:

1. Set up some imports
2. Construct some basic s4j factory objects (it's not called 4J 4 nothing)
3. Make an s4j point representing your desired center lat/lon
4. Pick a random offset within your desired radius
5. Pick a random angle (0 - 360 degrees) to offset your point
6. Convert your distance (in meters) to an appropriate offset (in /degrees/) at your target lat/lon.
7. Make your new random point
** Imports
First, set up some imports:

#+BEGIN_SRC scala
import org.locationtech.spatial4j.context.SpatialContext
import org.locationtech.spatial4j.distance.DistanceUtils
#+END_SRC

** Factory Stuff
Spatial4J uses a Factory object called a [[https://locationtech.github.io/spatial4j/apidocs/org/locationtech/spatial4j/context/SpatialContext.html][SpatialContext]] for many of its core APIs. There are a lot of different ways to configure this depending on your needs, but for the most common use-cases they include a static implementation under =SpatialContext.GEO=:


#+BEGIN_SRC scala
val context = org.locationtech.spatial4j.context.SpatialContext.GEO
#+END_SRC

** Make a point object out of your lat/lon
We'll use another factory off of our =SpatialContext= to construct this. Remember Lon is X and Lat is Y in Geospatial tech:

#+BEGIN_SRC scala
val lat = 33.94
val lon = -118.41
val startPoint = context.getShapeFactory.pointXY(lon, lat)
#+END_SRC

** Pick your random distance offset

#+BEGIN_SRC scala
val radius = 1000
val offsetMeters = scala.util.Random.nextDouble * radius
#+END_SRC

** Pick your random bearing

#+BEGIN_SRC scala
val bearingDegrees = scala.util.Random.nextDouble * 360
#+END_SRC

** Convert your linear distance to angular units (degrees)
This is the kicker for working with geodesic libraries like Spatial4J. It operates in a polar context, dealing with radii and angles (lat/lon) from the earth, but a distance like 500 meters is cartesian, dealing with flat distances on the earth's surface.

Fortunately there are ways to convert between the 2. In particular Spatial4J's [[https://locationtech.github.io/spatial4j/apidocs/org/locationtech/spatial4j/distance/DistanceUtils.html][DistanceUtils]] module includes some constants and utilities for this purpose:

#+BEGIN_SRC scala
val earthRadiusMeters = DistanceUtils.EARTH_MEAN_RADIUS_KM * 1000
val offsetDegrees = DistanceUtils.dist2Degrees(offsetMeters, earthRadiusMeters)
#+END_SRC


** Get a new point

Finally we can use another Spatial4J utility, =org.locationtech.spatial4j.distance.GeodesicSphereDistCalc=, to convert our start point, bearing, and offset to a new point.

Note that this uses a very Java-ish API, where you first construct the Point object yourself using a placeholder lat/lon and then pass it in to be modified by the Distance Calculator.

#+BEGIN_SRC scala
import org.locationtech.spatial4j.distance.GeodesicSphereDistCalc
val distCalc = new GeodesicSphereDistCalc.Vincenty

val newPoint = context.getShapeFactory.pointXY(0,0)
distCalc.pointOnBearing(startPoint, offsetDegrees, bearingDegrees, context, newPoint)
println(newPoint)
// Pt(x=-118.00099201867381,y=33.9950199965435)
#+END_SRC

** All together

Now that we've seen the pieces, we can assemble them into a nice utility function:

#+BEGIN_SRC scala
import org.locationtech.spatial4j.context.SpatialContext
import org.locationtech.spatial4j.distance.{DistanceUtils, GeodesicSphereDistCalc}
import org.locationtech.spatial4j.shape.Point

object PointGenerator {
  val context = org.locationtech.spatial4j.context.SpatialContext.GEO
  val distCalc = new GeodesicSphereDistCalc.Vincenty
  val earthRadiusMeters = DistanceUtils.EARTH_MEAN_RADIUS_KM * 1000

  def randPointInRadius(lat: Double, lon: Double, radius: Double): Point = {
    val startPoint = context.getShapeFactory.pointXY(lon, lat)
    val offsetMeters = scala.util.Random.nextDouble * radius
    val offsetDegrees = DistanceUtils.dist2Degrees(offsetMeters, earthRadiusMeters)
    val bearingDegrees = scala.util.Random.nextDouble * 360
    val newPoint = context.getShapeFactory.pointXY(0,0)
    distCalc.pointOnBearing(startPoint, offsetDegrees, bearingDegrees, context, newPoint)
    newPoint
  }
}
#+END_SRC

#+BEGIN_EXAMPLE
scala> PointGenerator.randPointInRadius(34.0,-118.0,500)
res1: org.locationtech.spatial4j.shape.Point = Pt(x=-118.00141054557675,y=33.9971987911845)
scala> PointGenerator.randPointInRadius(34.0,-118.0,500)
res2: org.locationtech.spatial4j.shape.Point = Pt(x=-117.99966381772931,y=33.997181705450046)
scala> PointGenerator.randPointInRadius(34.0,-118.0,500)
res3: org.locationtech.spatial4j.shape.Point = Pt(x=-118.0008673083813,y=33.99933155556646)
scala> PointGenerator.randPointInRadius(34.0,-118.0,500)
res4: org.locationtech.spatial4j.shape.Point = Pt(x=-117.99862804930764,y=34.001770697901655)
#+END_EXAMPLE

** A catch on distributions
This works great, but if we take a large sample and plot it on a map, we'll notice the points cluster tightly near the center:

#+BEGIN_SRC scala
(0 to 1000).map(_ => PointGenerator.randPointInRadius(33.94,-118.41,2000)).map(p => s"${p.getY},${p.getX}").foreach(println)
// 33.93769610837791,-118.39618482618667
// 33.944086950586815,-118.41270519841264
// 33.938436141001375,-118.41187357399744
// 33.93224346396654,-118.39866113148551
// etc
// Copy + paste | geoq map
#+END_SRC

It turns out that because of the way area and circles work, taking a random distance offset within our desired radius doesn't give a uniform distribution throughout the circle, but rather clusters the points toward the center.

If we want a smooth distribution over the area described by our point and radius, we'll need to sample radii exponentially weighted toward the max radius. That is, we want:

#+BEGIN_SRC scala
val offsetMeters = scala.math.sqrt(scala.util.Random.nextDouble) * radius
#+END_SRC

We could even give our users an option to toggle between these choices when using the function:

#+BEGIN_SRC scala
import org.locationtech.spatial4j.context.SpatialContext
import org.locationtech.spatial4j.distance.{DistanceUtils, GeodesicSphereDistCalc}
import org.locationtech.spatial4j.shape.Point
import scala.util.Random
import scala.math

object PointGenerator {
  val context = org.locationtech.spatial4j.context.SpatialContext.GEO
  val distCalc = new GeodesicSphereDistCalc.Vincenty
  val earthRadiusMeters = DistanceUtils.EARTH_MEAN_RADIUS_KM * 1000

  def randPointInRadius(lat: Double, lon: Double, radius: Double, evenDistribution: Boolean): Point = {
    val startPoint = context.getShapeFactory.pointXY(lon, lat)
    val offsetMeters = if (evenDistribution) {
      math.sqrt(Random.nextDouble) * radius
    } else {
      Random.nextDouble * radius
    }
    val offsetDegrees = DistanceUtils.dist2Degrees(offsetMeters, earthRadiusMeters)
    val bearingDegrees = Random.nextDouble * 360
    val newPoint = context.getShapeFactory.pointXY(0,0)
    distCalc.pointOnBearing(startPoint, offsetDegrees, bearingDegrees, context, newPoint)
    newPoint
  }
}
#+END_SRC

#+BEGIN_SRC scala
(0 to 1000).map(_ => PointGenerator.randPointInRadius(34.0,-118.0,2000, true)).map(p => s"${p.getY},${p.getX}").foreach(println)
// 33.939640262698276,-118.43135364227057
// 33.946446329758274,-118.4285590217258
// 33.927846243486826,-118.40795788351743
// 33.922739829504145,-118.41091483844558
// 33.93132724358199,-118.41135336156653
// 33.941905760094876,-118.42909622711291
// 33.939879012731645,-118.39112410484391
// etc...
#+END_SRC

** Clj
This is using Spatial4J.

#+BEGIN_SRC clojure
(import (org.locationtech.spatial4j.context SpatialContextFactory)
        (org.locationtech.spatial4j.context.jts JtsSpatialContext)
        (org.locationtech.spatial4j.distance DistanceUtils))

;; Setup
;; create a spatial context based on Spatial4J's generic Earth model
(def s4j-earth (SpatialContextFactory/makeSpatialContext
            {"geo" "true"
             "datelineRule" "width180"
             "spatialContextFactory" "org.locationtech.spatial4j.context.jts.JtsSpatialContextFactory"
             "distCalculator" "vincentySphere"}
            (.getClassLoader JtsSpatialContext)))
;; Create a distance calculator to use for generating offset points
(def vincenty-distance-calculator (org.locationtech.spatial4j.distance.GeodesicSphereDistCalc$Vincenty.))

(def radius 500) ;; meters
(def lat 33.9103414)
(def lon -118.428336)

(def center-point (.makePoint s4j-earth lon lat))

;; Generate a random offset within the given radius
(def offset-meters (* (rand) radius))

;; Spatial4J's pointOnBearing operates in angular rather than linear distance, so
;; we need to convert the desired offset (in meters) to earth radius (in degrees)
(def earth-radius (* 1000 DistanceUtils/EARTH_MEAN_RADIUS_KM))
(def offset-radians (DistanceUtils/dist2Radians offset-meters earth-radius))
(def offset-degrees (DistanceUtils/toDegrees offset-radians))

;; Pick a random angle
(def angle-degrees (rand 360))

;; Generate a new point at the desired distance on the desired angle

(def new-point (.pointOnBearing vincenty-distance-calculator
                                center-point
                                offset-degrees
                                angle-degrees
                                s4j-earth
                                nil))
#+END_SRC

Producing a uniform distribution within the radius:

#+BEGIN_SRC clojure
(def offset-meters (* (Math/sqrt (rand)) radius))
#+END_SRC
